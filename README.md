The main file is project3.py, and this is where everything will run from. The file works by listening to arguments in the command terminal and does not work by just compiling it. The program takes in the arguments from the command line and tries to perform actions to an index file given to it to use them. It can create a new index file with the correct header format, it can insert a key/value pair into the tree, it can search through the file based on a key given, it can load new values from the correct .csv file, it can print out all pairs in an index file, and it can write the contents of an index file to a .csv file. Creating a file works by making a node, filling up the header with the correct information, initializing the other values, and then inserting them from there. Once the user writes it, we put the least recently used nodes in the cache. The file has 2 modes, a read only and a read and write to ensure nothing weird happens during operations. After we create the root, we can insert, and this one is the one that takes the longest. There is a scenario for the root, inserting on a not full node, and a scenario for splitting them apart. The root node is simple, as all you do is start it at the base, put the next block as zero, fill the header, put in the pair, and you’re good. Inserting on nonfull does not need to do all these steps, only some of the above. Splitting the child node apart required me to fairly distribute out the previous values, make a new parent from what was in there, and make the children. Inorder traversal is more like a loop that goes through all the nodes to get the key and value pair in all of them, which is needed for print and extract. Print then prints the key and value, and goes through the traversal to make sure it prints out everything. Extract opens a file, and does the same function print does, except it writes to a .csv file instead. Search finds the value associated with the key by incrementing through all available keys currently in the tree, and returning false if nothing is found. There are two functions that allow the program to know whether to be in read only mode or write and read mode. There is also a function that can read the header to validate the file is workable, and one to write the header if we need to change the file or create a new header. The command line arguments work by passing it based on a series of if statements that the user gives, and there is a error handling that will inform the user how to run it, should they mess up. The command line functions simply make sure that even if the command is correct, that they have the right number of arguments and the files given exist. If both are valid, it passes in the filename as the btree, and calls the function needed for the operation. 

You need to run this in the command line, in the directory this file is contained in. The user must have python 3.12 installed to run it, and once they do, they can run it in the command terminal. All commands must start with “python project3.py,” with the desired command, followed by the arguments needed for the command afterwards. For example, insert would run like this: python project3.py insert filename.idx 15 100, with 15 being the key and 100 being the value. All arguments come after the command, which will affect what happens. Honestly this project was worked on a bit off the record in terms of dev logs, as I found it hard recently until now to work uninterrupted for long periods of time to log my thoughts.  I’m sure there’s more that I missed with the readme but I have given a very board overview of the program already
