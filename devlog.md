# Devlog for project 3

## 10:30 am 12/10/2025

This project involves using the command line to make and manipulate index files. The index files that we used are made up of blocks with 512 bytes, with each node fitting in one 512 byte block. New nodes that show up are appended to the end of the file. The header format of each file will have "4348PRJ3" to indicate it is an inded file a part of our project, the id of the block that is the root node (0 if none), and the id of the next block that will be added to the file if it is written to. The remainder space is unused. We need to arrange this in big endian order with 8 byte integers, so bigger numbers will be at the top of the b-tree more. Speaking of the B-Tree it is degree of 10, so it can have 19 key/pair values at any level, with 20 child pointers. Each node has header information stored in with it at its block. The first 8 bytes is the block id the node is stored in, then the next 8 bytes is the block id of the parent node, then the next 8 bytes is the key/pair node. After this, the next 152 bytes is 19 64 bit keys that could relate to them next, then the next 152 bytes are the values associated with the keys, then the next 160 bytes are children associated with these nodes (0 if there are no children, as it is a leaf node). Keep in mind that the key/pair byte chucks directly relate to another, so the second key corresponds to the second value stored. The child pointers have to be less then the following pointers, but greater then the previous. As for the command lines, they are pretty straightforward. Everything needs to be run by specifying the name of the file as project3, and then followed by the command then needed arguments afterwards. The create command makes a file with the name of the argument following command, and will simply fail if that filename already exists. The insert command adds a key/value pair of unsigned integers to the file name given in the first argument, with the key/value pair being the second and third argument respectively; fails if the file doesn't exist. The search command finds the key/value pair in the file given in the first argument, based off the key (and only the key) given to it in the second argument; prints an error if the file doesn't exist or if the pair doesn't exist. The load command is far more complicated, as the file name given in the first argument is given a list of values to add to the file; the second argument is a .csv file that has values that can be added into the index file. This command files if either file does not currently exist. It basically acts an insert command with a loop inside the file. The print command is far simpler, as it prints out every key/value pair in the index file given in the first argument, and simply fails if the file doesn't exist. The extract command the last command, and it outputs the index file given in the first argument to a .csv file. The .csv file is made by the program, its name is based on the second argument, and has the key/value pairs of the index file given is the contents of it. The command can fail if the index file doesn't exist or if the .csv file name already exists. My plan of action is starting simply and then diving into more complex actions. I will simply start by making universal constants and variables, reading in the command line arguments, making functions for them. I am a bit worried about making the index files, but I will try and find resources on how to make them on the internet. My plan first however, is trying to make the files and handle what I already know what to do first, and move onto the other steps. I will try and work on file creation and reading first, as I think this will take more time, and then move onto the command line arguments. 

## 11:17am 12/10/2025
So my main thoughts right now are, how do I make the index file? I have never worked with these kinds of files before this, so I will try my best to research it and learn about them. Other then that, my basic idea right now is to handle the command line arguments, and then make universal variables that can help with my program running. I will implement a function also that makes integers to bytes like described in the program, and vice versa, as this will make it smoother once it does happen. The goal for right now is try to make the index file work. 

## 11:44am 12/10/2025
I learned today that Python does not have switch statements, so I have to use else-if statements for the command line. I also included the function usageandexit as a way to error check the commands later potentially. 

## 12:43pm 12/10/2025
I didn't really account for making a node in my program, but I realized that I probably should, as when I was thinking about it, it would make more sense to the file more like a collection of nodes, so I figured I would make the node class first. It's a bit weird I have to initialize it according to the bit number and then fill in the values later with a static method, as they almost do the same thing, but I do need them because I have to modify the nodes eventually when the b-tree expands and needs to be adjusted. I will work on the b-tree next, which will probably take a while after this. 

## 1:36pm 12/10/2025
After a bit of research, it turns out this is actually able to be made, but we need to be careful about how we write and read to the file. Therefore, I have made read only functions, so when operations like print are given, it cannot modify the file. It is also able to modify the header by reading the first 24 bits and validates if this is the correct kind of file. We will have to deal with cache next. This will also help us deal with writing the nodes and disk management.  
