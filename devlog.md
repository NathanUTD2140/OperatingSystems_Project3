# Devlog for project 3

## 10:30 am 12/10/2025

This project involves using the command line to make and manipulate index files. The index files that we used are made up of blocks with 512 bytes, with each node fitting in one 512 byte block. New nodes that show up are appended to the end of the file. The header format of each file will have "4348PRJ3" to indicate it is an inded file a part of our project, the id of the block that is the root node (0 if none), and the id of the next block that will be added to the file if it is written to. The remainder space is unused. We need to arrange this in big endian order with 8 byte integers, so bigger numbers will be at the top of the b-tree more. Speaking of the B-Tree it is degree of 10, so it can have 19 key/pair values at any level, with 20 child pointers. Each node has header information stored in with it at its block. The first 8 bytes is the block id the node is stored in, then the next 8 bytes is the block id of the parent node, then the next 8 bytes is the key/pair node. After this, the next 152 bytes is 19 64 bit keys that could relate to them next, then the next 152 bytes are the values associated with the keys, then the next 160 bytes are children associated with these nodes (0 if there are no children, as it is a leaf node). Keep in mind that the key/pair byte chucks directly relate to another, so the second key corresponds to the second value stored. The child pointers have to be less then the following pointers, but greater then the previous. As for the command lines, they are pretty straightforward. Everything needs to be run by specifying the name of the file as project3, and then followed by the command then needed arguments afterwards. The create command makes a file with the name of the argument following command, and will simply fail if that filename already exists. The insert command adds a key/value pair of unsigned integers to the file name given in the first argument, with the key/value pair being the second and third argument respectively; fails if the file doesn't exist. The search command finds the key/value pair in the file given in the first argument, based off the key (and only the key) given to it in the second argument; prints an error if the file doesn't exist or if the pair doesn't exist. The load command is far more complicated, as the file name given in the first argument is given a list of values to add to the file; the second argument is a .csv file that has values that can be added into the index file. This command files if either file does not currently exist. It basically acts an insert command with a loop inside the file. The print command is far simpler, as it prints out every key/value pair in the index file given in the first argument, and simply fails if the file doesn't exist. The extract command the last command, and it outputs the index file given in the first argument to a .csv file. The .csv file is made by the program, its name is based on the second argument, and has the key/value pairs of the index file given is the contents of it. The command can fail if the index file doesn't exist or if the .csv file name already exists. My plan of action is starting simply and then diving into more complex actions. I will simply start by making universal constants and variables, reading in the command line arguments, making functions for them. I am a bit worried about making the index files, but I will try and find resources on how to make them on the internet. My plan first however, is trying to make the files and handle what I already know what to do first, and move onto the other steps. I will try and work on file creation and reading first, as I think this will take more time, and then move onto the command line arguments. 

## 11:17am 12/10/2025
So my main thoughts right now are, how do I make the index file? I have never worked with these kinds of files before this, so I will try my best to research it and learn about them. Other then that, my basic idea right now is to handle the command line arguments, and then make universal variables that can help with my program running. I will implement a function also that makes integers to bytes like described in the program, and vice versa, as this will make it smoother once it does happen. The goal for right now is try to make the index file work. 

## 11:44am 12/10/2025
I learned today that Python does not have switch statements, so I have to use else-if statements for the command line. I also included the function usageandexit as a way to error check the commands later potentially. 

## 12:43pm 12/10/2025
I didn't really account for making a node in my program, but I realized that I probably should, as when I was thinking about it, it would make more sense to the file more like a collection of nodes, so I figured I would make the node class first. It's a bit weird I have to initialize it according to the bit number and then fill in the values later with a static method, as they almost do the same thing, but I do need them because I have to modify the nodes eventually when the b-tree expands and needs to be adjusted. I will work on the b-tree next, which will probably take a while after this. 

## 1:36pm 12/10/2025
After a bit of research, it turns out this is actually able to be made, but we need to be careful about how we write and read to the file. Therefore, I have made read only functions, so when operations like print are given, it cannot modify the file. It is also able to modify the header by reading the first 24 bits and validates if this is the correct kind of file. We will have to deal with cache next. This will also help us deal with writing the nodes and disk management.  

## 2:07pm 12/10/2025
This creates and reads nodes. I will make the B-Tree operations next, as this will be where the file creation and general command operations will operate in. This part was pretty simple, but this one might take me a while. 

## 3:39pm 12/10/2025 
Having to insert the nodes was very complicated and needed far more logic then I could have guessed. I didn't really think about trying to split it, so when I thought about all the cases, I realized that I needed to be able to split it. It required some research on my part to fully understand how I can split them apart. The root case and inserting on a non full was far more straightforward. Creating the file and searching through it was far simpler in comparison. I believe that the next steps is to make the other commands, hopefully they will be simpler. Going to take a break for now. 

## 3:42pm 12/10/2025 
Today's session was pretty productive. I think that the main thing is things kept building up in some ways that I did not expect. I was able to make it so we can make a node, which is important for making our files. It can read in some commands and handle errors while telling the user they were wrong. For the file operations, we can make a file with our program, validate its correctness, and perform some operations we needed also. Insertion was very complicated, and I did not expect to have almost 4 different ways to insert the nodes. I feel like I have done some of the most difficult parts. I got more tired then I expected, so I will develop the rest after my needed tasks today. 

## 8:35pm 12/10/2025 
The next session will see me link the commands that the user gives in the terminal to the operations of the btree. In addition, I will make it possible to print, load and extract an csv file. I will go about the first part by making methods that error handle the arguments and file names, and then pass it with an instance of the btree based upon the file given to the program. I will do the second part by making it traverse through the tree, printing out every key/value pair, and then doing the same thing for an output file that will act as a glorified print statement. I need to traverse the tree because I need all the values, and if I'm going to have two print functions, this will be needed. I also need to read from an .csv which will be new for me. Handling the arguments will be easy, as I will check if the arguments are correct, if the file exists, put the btree as the filename given to us, and then call the corresponding functions to use it. My goal for this session is to finish the program with these editions, test how good it is, and fix any bugs. 

## 8:59pm 12/10/2025
First, the inorder transversal was made based off the regular btree operations. I need this to go through all the keys in order, and then print the values based off the keys. 

## 9:22pm 12/10/2025
The .csv files are honestly not as bad as I thought, it acts like regular file management. Make sure the file is valid or needs to be created first. Open the file if we are writing, write to the file with a writer, and keep going. If we're reading from a file, open the file, use a reader, and read the needed data, strip away excess information, and put it into the file.  
